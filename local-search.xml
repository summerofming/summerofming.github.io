<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>自然语言处理笔记（一）：语义向量</title>
    <link href="/2023/11/29/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B01/"/>
    <url>/2023/11/29/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<p>人们平时对话、写作和交流时使用的语言被称为自然语言。虽然对人类来说语言的天赋仿佛与生俱来，但对计算机来说，让它直接理解和处理自然语言是比较困难的。这是因为自然语言是非结构化的：没有一个统一的语法结构能解释所有的语言；同个语句在不同的语境（上下文）中的涵义甚至有所不同。想让计算机来理解命令或生成文字，关键在于将自然语言转化成一种结构化的表示形式。当自然语言能够像数学语言一样被定量处理时，计算机就可以对自然语言进行分析、理解和回应。这篇文章基于<a href="https://radimrehurek.com/gensim/intro.html">Gensim</a>的文档，来介绍自然语言处理（NLP）的基础技巧：将文档表示为向量。<em>Gensim旨在使用无监督机器学习算法处理原始的非结构化纯文本</em>。</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="1-Document"><a href="#1-Document" class="headerlink" title="1. Document"></a>1. Document</h4><p>文档（Document）是<code>字符串</code>，包括句子、段落或文章等。例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">document = &quot;人工智能的快速发展正在改变我们的生活方式。&quot;<br></code></pre></td></tr></table></figure><h4 id="2-Corpus"><a href="#2-Corpus" class="headerlink" title="2. Corpus"></a>2. Corpus</h4><p>语料库（Corpus）是Document的<code>集合</code>。例如下面由5个文档构成的语料库：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">text_corpus = [<br>    &quot;人工智能的快速发展正在改变我们的生活方式。&quot;,<br>    &quot;健康饮食和锻炼是保持身体健康的重要方式。&quot;,<br>    &quot;人类探索太空的努力正在取得令人瞩目的成果。&quot;,<br>    &quot;自然语言处理是人工智能领域中的一个重要方向。&quot;,<br>    &quot;Python有着众多优秀的第三方库和框架。&quot;<br>]<br></code></pre></td></tr></table></figure><p>实际使用时，语料库可能非常大，因此一次性将整个语料库加载到内存里不合适，Gensim通过一次传输一个文档的<code>流式传输</code>来智能地处理大型语料库。</p><h5 id="对语料库的预处理：分词与过滤"><a href="#对语料库的预处理：分词与过滤" class="headerlink" title="对语料库的预处理：分词与过滤"></a>对语料库的预处理：分词与过滤</h5><p>text_corpus列表中每个文档字符串看起来很长，而且有些字词（例如“的”）在文档中经常出现，因此可以对语料库中的文档进行分词（更一般地称<em>Tokenization</em>）和过滤等预处理。</p><ul><li><p>对于英文字符串的分词，最简单的就是用空格来将一句话拆分成一个个单词。</p></li><li><p>对于中文字符串的分词，简单的可以采用jieba等传统分词方法。</p></li><li><p>对于Transformer等深度学习模型在处理自然语言时通常采用基于子词（subword）或字级别的分词，而不是传统的词级别分词。</p></li></ul><p>接下来用python的jieba库，对上述text_corpus语料库进行分词：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">import</span> jieba<br><span class="hljs-keyword">import</span> pprint<br><br>text_corpus = [<br>    <span class="hljs-string">&quot;人工智能的快速发展正在改变我们的生活方式。&quot;</span>,<br>    <span class="hljs-string">&quot;Python可以实现文本分类等NLP任务。&quot;</span>,<br>    <span class="hljs-string">&quot;人工智能领域正取得令人瞩目的成果。&quot;</span>,<br>    <span class="hljs-string">&quot;NLP是人工智能领域中的一个重要方向。&quot;</span>,<br>    <span class="hljs-string">&quot;Python有着众多优秀的第三方库和框架。&quot;</span><br>]<br><br>texts = []<br><span class="hljs-keyword">for</span> document <span class="hljs-keyword">in</span> text_corpus:<br>    texts.append(jieba.lcut(document))<br>pprint.pprint(texts)<br></code></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">[[&#x27;人工智能&#x27;, &#x27;的&#x27;, &#x27;快速&#x27;, &#x27;发展&#x27;, &#x27;正在&#x27;, &#x27;改变&#x27;, &#x27;我们&#x27;, &#x27;的&#x27;, &#x27;生活&#x27;, &#x27;方式&#x27;, &#x27;。&#x27;],<br> [&#x27;Python&#x27;, &#x27;可以&#x27;, &#x27;实现&#x27;, &#x27;文本&#x27;, &#x27;分类&#x27;, &#x27;等&#x27;, &#x27;NLP&#x27;, &#x27;任务&#x27;, &#x27;。&#x27;],<br> [&#x27;人工智能&#x27;, &#x27;领域&#x27;, &#x27;正&#x27;, &#x27;取得&#x27;, &#x27;令人瞩目&#x27;, &#x27;的&#x27;, &#x27;成果&#x27;, &#x27;。&#x27;],<br> [&#x27;NLP&#x27;, &#x27;是&#x27;, &#x27;人工智能&#x27;, &#x27;领域&#x27;, &#x27;中&#x27;, &#x27;的&#x27;, &#x27;一个&#x27;, &#x27;重要&#x27;, &#x27;方向&#x27;, &#x27;。&#x27;],<br> [&#x27;Python&#x27;, &#x27;有着&#x27;, &#x27;众多&#x27;, &#x27;优秀&#x27;, &#x27;的&#x27;, &#x27;第三方&#x27;, &#x27;库&#x27;, &#x27;和&#x27;, &#x27;框架&#x27;, &#x27;。&#x27;]]<br></code></pre></td></tr></table></figure><p>继续统计字词的频率，并去除高频常用词：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br>frequency = defaultdict(<span class="hljs-built_in">int</span>)<br><span class="hljs-comment"># 统计词频</span><br><span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> texts:<br>    <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> text:<br>        frequency[token] += <span class="hljs-number">1</span><br><span class="hljs-comment">#print(dict(frequency))</span><br><br><span class="hljs-comment"># 创建待过滤的高频词列表</span><br>stoplist = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;的 是 和 中 一个 有着 。&#x27;</span>.split(<span class="hljs-string">&#x27; &#x27;</span>))<br><span class="hljs-comment"># 提取语料库主要内容</span><br>processed_corpus = [[token <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> text <span class="hljs-keyword">if</span> (token <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> stoplist) &amp; (frequency[token] &gt; <span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> texts]<br>pprint.pprint(processed_corpus)<br></code></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[[&#x27;人工智能&#x27;], [&#x27;Python&#x27;, &#x27;NLP&#x27;], [&#x27;人工智能&#x27;, &#x27;领域&#x27;], [&#x27;NLP&#x27;, &#x27;人工智能&#x27;, &#x27;领域&#x27;], [&#x27;Python&#x27;]]<br></code></pre></td></tr></table></figure><p>因此，经过预处理之后，语料库的主要信息被提取成与“人工智能、NLP、Python、领域”这四个token相关的内容。</p><p>接着，还可以使用<code>gensim.corpora.Dictionary</code> 类将语料库中每个<strong>独一</strong>的token与唯一的整数ID相关联：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gensim <span class="hljs-keyword">import</span> corpora<br><br>dictionary = corpora.Dictionary(processed_corpus)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">dict</span>(dictionary))<br><span class="hljs-comment"># &#123;0:&#x27;人工智能&#x27;, 1:&#x27;NLP&#x27;, 2:&#x27;Python&#x27;, 3:&#x27;领域&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-Vector"><a href="#3-Vector" class="headerlink" title="3. Vector"></a>3. Vector</h4><p>为了能对文档（Document）进行结构化的处理，需要将每个文档转化成数学向量（Vector）。</p><ul><li><p>第一种方法是将每个文档表示为特征向量。</p><p>例如可以手动构造一些特征问题：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">1. &quot;人工智能&quot;这个词在该文档中出现了多少次？<br>2. 该文档由多少个段落组成？<br>3. 该文档使用了多少种字体？<br></code></pre></td></tr></table></figure><p>在以上特征问题下，<code>document1 = &quot;人工智能的快速发展正在改变我们的生活方式。&quot;</code>对应的回答是<code>(1, 1, 1)</code>，<code>document2 = &quot;Python可以实现文本分类等NLP任务。&quot;</code>对应的回答是<code>(0, 1, 1)</code>。这样我们就将每个文档转化成一系列对应特征问题的稠密(dense)向量。当然，这种向量表示的形式依赖于我们的特征问题问的是否恰当，因此适用于文档的特征比较明确的情况下。另外，在Gensim中只允许问答案是（或可以转换为）单个浮点数的问题。</p><p>如果我们用同一组特征问题来将语料库中的每个文档都表示成对应的特征向量，例如得到document_x &#x3D; (1, 2, 3)，document_y &#x3D; (0.9, 2.1, 3.1)，我们会认为document_x和document_y非常相近，从而认为这两个文档原来的字符串是相似的。</p></li><li><p>第二种方法叫做词袋模型（bag-of-words model）。</p><p>在词袋模型下，每个文档都由一个数学向量表示，该向量是<strong>字典中每个单词在文档中出现的频数</strong>。</p><p>例如，假设我们事先有一本包含单词的字典，字典里面有四个单词：”咖啡”、 “牛奶”、”糖”、”勺子”。那么对于文档<code>document_0 = &quot;一杯咖啡牛奶。&quot;</code>则可以表示成向量<code>(1,1,0,0)</code>，因为这个文档字符串中出现了1次”咖啡”、1次”牛奶”、0次”糖”、0次”勺子”。</p><p>词袋模型的一个重要特点是它完全忽略了编码文档中token的顺序。</p><p>回到上面预处理过程中<code>processed_corpus</code>的例子，其中</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">processed_corpus = <br>[[&#x27;人工智能&#x27;], <br> [&#x27;Python&#x27;, &#x27;NLP&#x27;], <br> [&#x27;人工智能&#x27;, &#x27;领域&#x27;], <br> [&#x27;NLP&#x27;, &#x27;人工智能&#x27;, &#x27;领域&#x27;], <br> [&#x27;Python&#x27;]]<br></code></pre></td></tr></table></figure><p>我们通过<code>dictionary = corpora.Dictionary(processed_corpus)</code>语句构建了一个字典<code>&#123;0:&#39;人工智能&#39;, 1:&#39;NLP&#39;, 2:&#39;Python&#39;, 3:&#39;领域&#39;&#125;</code>，现在看看在这个字典下，processed_corpus可以表示成什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">bow_corpus = [dictionary.doc2bow(text) <span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> processed_corpus]<br>pprint.pprint(bow_corpus)<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">[[(0, 1)],<br> [(1, 1), (2, 1)],<br> [(0, 1), (3, 1)],<br> [(0, 1), (1, 1), (3, 1)],<br> [(2, 1)]]<br></code></pre></td></tr></table></figure><p>这样我们就把processed_corpus表示成了一系列的向量。其中第一行<code>[(0, 1)]</code>对应于<code>[&#39;人工智能&#39;]</code>，元组(0, 1)中的0代表在字典中的ID&#x3D;0，元组(0, 1)中的1代表字典中的元素在该文档中出现的频数为1次。</p><p>由于任何给定文档仅包含字典中众多单词中的几个单词，因此作为节省空间的措施，未出现在矢量化中的单词将隐式表示为零。</p></li></ul><h4 id="4-Model"><a href="#4-Model" class="headerlink" title="4. Model"></a>4. Model</h4><p>模型（Model）可以对向量（Vector）进行转换，即把文档从一种表示形式转换为另一种表示形式。</p><p>转换文档向量的表示有两个原因：一是为了揭示语料库中的隐藏结构，发现单词之间的关系，并使用它们以更语义化的方式描述文档的关系；二是使文档表示更加紧凑，既提高了效率 （新的表示消耗更少的资源）又提高了功效（忽略了边际数据趋势，减少了噪声）。这些需要通过模型（Model）来实现。</p><p>模型的一个简单示例是tf-idf（词频-逆文档频率）（虽然简单，但在过滤垃圾邮件等任务上已有很好的表现）。tf-idf 模型将向量从词袋表示转换到另一个向量空间，其中在该向量空间中的频数会根据语料库中每个单词的相对稀有度进行加权，因此越是重要的特征词权重就越大。</p><p>例：初始化 tf-idf 模型，在bow_corpus上对其进行训练：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gensim <span class="hljs-keyword">import</span> models<br><br><span class="hljs-comment"># train the model</span><br>tfidf = models.TfidfModel(bow_corpus)<br></code></pre></td></tr></table></figure><p>创建模型后，可以通过 TfIdf 转换整个语料库并对其进行索引，为相似性查询做准备</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gensim <span class="hljs-keyword">import</span> similarities<br><br>index = similarities.SparseMatrixSimilarity(tfidf[bow_corpus], num_features=<span class="hljs-number">4</span>)<br><span class="hljs-comment"># 使用余弦相似性计算向量的相似度</span><br></code></pre></td></tr></table></figure><p>现在假设来了一个新的字符串<code>query_document=&quot;人工智能与NLP&quot;</code>，我们可以查询它与<code>processed_corpus</code>中的哪个text更像。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">query_document = jieba.lcut(<span class="hljs-string">&#x27;人工智能与NLP&#x27;</span>)<br>query_bow = dictionary.doc2bow(query_document)<br>sims = index[tfidf[query_bow]]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">enumerate</span>(sims)))<br></code></pre></td></tr></table></figure><p>结果显示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[(0, 0.4869355), (1, 0.61761385), (2, 0.23710617), (3, 0.75315946), (4, 0.0)]<br></code></pre></td></tr></table></figure><p>注意到<code>&quot;人工智能与NLP&quot;</code>本来就与processed_corpus中的<code>[&#39;NLP&#39;, &#39;人工智能&#39;, &#39;领域&#39;]</code>最为相关，结果也确实显示了(3, 0.75315946)对应的相似度最高，达到75.3%。</p><p>除了 tf-idf 模型外，基于词频的常用模型还有：</p><ul><li><p>Okapi BM25：对于给定的一个查询（query）和若干文档，搜索引擎使用Okapi BM25作为标准的排名函数来为文档的相关性打分。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">model</span> <span class="hljs-operator">=</span> models.OkapiBM25Model(corpus)<br></code></pre></td></tr></table></figure></li><li><p>LSA（潜在语义索引，多项式 PCA）：将文档从词袋或TfIdf 加权空间转换为较低维度的潜在空间。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">model = models.LsiModel(tfidf_corpus, <span class="hljs-attribute">id2word</span>=dictionary, <span class="hljs-attribute">num_topics</span>=300)<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>音乐发现（持续更新）</title>
    <link href="/2023/11/08/Todo%EF%BC%9A%E8%BF%98%E6%9C%89%E9%9F%B3%E4%B9%90/"/>
    <url>/2023/11/08/Todo%EF%BC%9A%E8%BF%98%E6%9C%89%E9%9F%B3%E4%B9%90/</url>
    
    <content type="html"><![CDATA[<p>在B站上有位UP主用数据分析（傅里叶变换）的方法，定义了一个“平均歌”的概念，然后分析从1998年到2021年华语乐坛的演变。<a href="https://www.bilibili.com/video/BV1m8411P7v7/?spm_id_from=333.337.search-card.all.click">关于流行音乐的深度研究：华语音乐已经完蛋了吗？_哔哩哔哩_bilibili</a>。最后的结论非常有趣，从“平均歌”的角度来看，音乐质量并没有明显下滑；但从方差的角度来看，近几年“离谱歌”的质量确实不及从前。</p><p>在这篇文章里，想要记录那些仍能带给我们感动的新歌。能从2016年以后的音海中，偶遇这些歌曲，不失为一种乐趣。当然判断一首歌是否好听，全凭主观喜好，每时每刻的经历和思绪都不相同，能有一刻的共鸣即是幸运。因此只做简单的记录，并非排名。</p><table><thead><tr><th align="center">歌曲</th><th align="center">演唱</th><th align="center">年份</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">归途有风</td><td align="center">王菲</td><td align="center">2022</td><td align="center">要风起 要别离 要万里 要归期不由你</td></tr><tr><td align="center">这世界那么多人</td><td align="center">莫文蔚</td><td align="center">2021</td><td align="center">身旁那么多人 可世界不声不响</td></tr><tr><td align="center">水星记</td><td align="center">郭顶</td><td align="center">2016</td><td align="center">等到分不清季节更替 才敢说沉溺</td></tr><tr><td align="center">我喜欢上你时的内心活动</td><td align="center">陈绮贞</td><td align="center">2017</td><td align="center">我们还去吗</td></tr><tr><td align="center">Mojito</td><td align="center">周杰伦</td><td align="center">2020</td><td align="center">中间的rap点睛</td></tr><tr><td align="center">山海</td><td align="center">草东没有派对</td><td align="center">2016</td><td align="center">我看着 天真的我自己</td></tr><tr><td align="center">伟大的渺小</td><td align="center">林俊杰</td><td align="center">2017</td><td align="center">陪你放肆地年少</td></tr><tr><td align="center">交换余生</td><td align="center">林俊杰</td><td align="center">2020</td><td align="center">也才算无愧这分合</td></tr><tr><td align="center">平凡之路</td><td align="center">朴树</td><td align="center">2017</td><td align="center">你要去哪</td></tr><tr><td align="center">倒数</td><td align="center">邓紫棋</td><td align="center">2018</td><td align="center">一点一滴每一天珍惜</td></tr><tr><td align="center">起风了</td><td align="center">买辣椒也用券&#x2F;周深&#x2F;林俊杰</td><td align="center">2018</td><td align="center">心之所动 且就随缘去吧</td></tr><tr><td align="center">追光者</td><td align="center">岑宁儿</td><td align="center">2017</td><td align="center">因为你有梦可做</td></tr><tr><td align="center">云之羽</td><td align="center">张杰</td><td align="center">2023</td><td align="center">我跨越山水奔向你</td></tr><tr><td align="center">大鱼</td><td align="center">周深</td><td align="center">2016</td><td align="center"></td></tr><tr><td align="center">雅俗共赏</td><td align="center">许嵩</td><td align="center">2016</td><td align="center">所以我爱进剧场</td></tr><tr><td align="center">早睡身体好</td><td align="center">许嵩</td><td align="center">2016</td><td align="center">夜色已浓郁 耗着也不会有惊喜</td></tr><tr><td align="center">永夜</td><td align="center">谭维维</td><td align="center">2018</td><td align="center">我唤来了星繁 似灭似绚烂</td></tr><tr><td align="center">如约而至</td><td align="center">许嵩</td><td align="center">2018</td><td align="center">或许爱能穿越时间 抵达永远</td></tr><tr><td align="center">……</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>收藏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漫话物理史(一)(古典物理学)</title>
    <link href="/2023/11/07/%E6%BC%AB%E8%AF%9D%E7%89%A9%E7%90%86%E5%8F%B21/"/>
    <url>/2023/11/07/%E6%BC%AB%E8%AF%9D%E7%89%A9%E7%90%86%E5%8F%B21/</url>
    
    <content type="html"><![CDATA[<blockquote><p><font face="楷体" size=4>昨日繁星皓月当空，辉光所至遍起楼层。今朝廊桥亭台水榭，不见当时璀璨虹星。</font></p></blockquote><p>&emsp;&emsp;当今理论物理学好久没有爆炸性新闻了，这并不是说所有的谜题都已被解开，而是反衬出先贤们建立的理论框架太过辉煌。从物理的旷野上望去，两栋摩天大楼最为瞩目，它们的楼盘上分别标注着<code>广义相对论</code>和<code>量子场论</code>，然而它们并没有连接在一起，而像是支撑天空的两根独立的柱子。抬头仰望天空，到处漂浮着积云，仿佛要招致一场暴雨，将高楼完全冲塌。本系列博文将要回顾物理学的发展历史，跟随巨星们的脚步感受理性的光芒，眼看着他们如何地起高楼。不得不说，那将是一个很长很长的故事……</p><h2 id="一、古典物理学"><a href="#一、古典物理学" class="headerlink" title="一、古典物理学"></a>一、古典物理学</h2><h3 id="1-1-仰望星空的泰勒斯"><a href="#1-1-仰望星空的泰勒斯" class="headerlink" title="1.1  仰望星空的泰勒斯"></a>1.1  仰望星空的泰勒斯</h3><p>&emsp;&emsp;在两千多年前 (约公元前6世纪) 某天的夜晚，泰勒斯走在古希腊某田野的泥路上。他一边望着遥远的星空，一边自说自话若有所思，不出所料，他摔进了一个深坑 (话说为什么那时候路面会被刨个坑呢？→_→)，他浑身伤痕累累，难以从坑中爬出。幸好有一个商人路过将他救起。泰勒斯为表示感谢，告诉了商人他的伟大发现，“明天会下雨！”，泰勒斯兴奋地说道。商人本以为会得到很好的报酬，此时却大失所望。但商人还是不打算亏本，他准备将这个事情当作笑料传遍足迹所到之处。从此一句名言流传开来：<font face="楷体" size=4>哲学家是只知道天上的事情而不知道脚下发生什么事情的人。</font>多亏好事商人的努力，泰勒斯成为了人尽皆知的仰望星空的明星。如今人们追溯物理学的起源时，往往把泰勒斯仰望星空作为标志性事件，从此<code>观测</code>与<code>预言</code>这样的组合成为了理性研究的范式。</p><p>&emsp;&emsp;泰勒斯的故事还没有落幕。他将目光投向了爱琴海的东岸，那里已持续了近三十年的战争。他准备用知识来停止这场灾难。泰勒斯自告奋勇当说客分别到两阵营主将那里谈判，“你们愚蠢的斗争已引起神的震怒，他将要让太阳失去光辉。” 双方将领都不以为然。待到再一天两方摆开阵型时，日食如期而至，士兵们恐慌万分，纷纷逃窜。主将们这才坐在一起签订合约永不再战。这也是史料记载的第一个被预测的日食。至于当时他是运用什么规律而预测到天象的，现在已不得而知。</p><h3 id="1-2-百科式全才的亚里士多德"><a href="#1-2-百科式全才的亚里士多德" class="headerlink" title="1.2 百科式全才的亚里士多德"></a>1.2 百科式全才的亚里士多德</h3><p>&emsp;&emsp;在公元前四世纪的某天，一位古希腊的公子正在柏拉图学院与老师激烈争论。他几乎不同意老师的各种观点。这位老师即是创办学院的柏拉图。柏拉图师从苏格拉底，继承着苏格拉底的智慧，并著有《理想国》一书来阐述自己的哲学理念。在柏拉图的思想中，他认为人的意识中存在着一个完美的国度，世间万物不过是意识的不完美的映射。比如，当我们眼睛看到一匹马时，柏拉图会这样解释到，人的意识中早就存在一个完美的马的意象，而现在的这匹马满身尘土，体格薄弱，是意识向现实妥协的一个有缺陷的映射，当我们看到现实的马时，完美的马的意象就会被唤醒，从而由眼睛告诉大脑，哈，那是一匹马。亚里士多德却觉得现实的马本来就存在，为什么要弯弯绕绕再引入一个看不见摸不着的更完美的它呢？简单点，说话的方式简单点。师徒二人僵持不下，亚里士多德放出豪言：<font face="楷体" size=4>吾爱吾师，吾更爱真理！</font></p><p>&emsp;&emsp;于是他打算重新思索学习的过程：人们到底是怎么获得关于外物的知识的呢？终于他迈出了认知外物的第一步：<code>分类</code>。将世间万物按一定规律分类为不同的集合。每个集合内部的事物拥有共同的性质，而集合之间的事物要有明显的不同。然后将每个集合起一个新的名字来定义它们。比如生物学的界门纲目层层分类。这时学习体现在哪里呢？原来将事物分类的过程就是学习。分类时由于需要知道所定义集合的共性，这就需要通过感官和逻辑等主观要素来掌握事物的不同特征。分类需要有一个前提，那就是第一个分类事物的人必须博学多闻，能建立一个內恰的框架。幸运的是，亚里士多德就是那个全才博学的人。他几乎对每个学科都做出了贡献。他的写作涉及伦理学、形而上学、心理学、经济学、神学、政治学、修辞学、自然科学、教育学、诗歌、风俗，以及雅典法律。亚里士多德的著作构建了西方哲学的第一个广泛系统，包含道德、美学、逻辑和科学、政治和玄学。有趣的是，在<code>机器学习/人工智能</code>发展的如火如荼的两千多年后的今天，电脑深度学习的头等要事也是<code>分类</code>，一个能精准执行分类任务的AI才是会学习的好AI。</p><p>&emsp;&emsp;伟大的人物也会被时代所限，事实上亚里士多德的分类标准过于简单，而一些结论也下的比较草率，这也导致了那时人们的思想长期受到束缚，无法思考更为深刻和广阔的空间。但我们在评价一位历史人物时要代入到他所在的时代来评价高低。毫无疑问，在古希腊时代，希腊三贤的功绩无出其右。</p><h3 id="1-3-阿基米德与浮力定理"><a href="#1-3-阿基米德与浮力定理" class="headerlink" title="1.3 阿基米德与浮力定理"></a>1.3 阿基米德与浮力定理</h3><p>&emsp;&emsp;时间来到公元前三世纪的一天夜晚，阿基米德正躺在澡盆里苦苦思索。原来古希腊的希洛国王命令他检测一个金冠是否掺假。他知道金属是否掺假可通过测量它们的密度来判断。如果金冠掺了劣质铝铁，那么密度就会减小。而如果想知道一个物体的密度，那首先要测得它的质量和体积。对于质量呢，可以用杆秤来称量。但是怎么测一个不规则体形的金冠的体积呢？阿基米德看着澡盆里的水面起起伏伏，突然脑袋旁边亮起一个”灯泡“：人本身也是一个不规则物体啊，我进入澡盆里水面上升，不是因为水被我的体积排开了吗？于是第二天他向国王借来与金冠等质量的真金子。他的逻辑线已逐渐清晰起来：质量一定，密度小的物体体积大！将金冠和等质量的真金分别投入水中，如果金冠掺假了那么它会导致水面上升更高！制作王冠的工匠们后来的命运已无史料记载，但阿基米德解决问题的方式却以另外一种方式流传下来，那就是<code>浮力定理 </code>(浸入静止流体中的物体会受到一个浮力，其大小等于该物体所排开的流体重量，方向沿流体法向并通过所排开流体的形心)。在中国古代的三国时期，曹冲利用了与阿基米德同样的方法测得了大象的体重。</p><p>&emsp;&emsp;阿基米德有一句名言：给我一个支点，我可以撬动地球！这当然是一种夸张的说法，因为根据由他自己提出的杠杆平衡原理推知，如果阿基米德想凭借自身重力撬起地球的话，即使一切实验设备都准备好了，而且他能够以光速运动，他也需要6万年的时间才能将地球撬起一厘米。虽然实验上无法为他验证，但是撬动地球理论上的可能性从未被人们怀疑。</p><h3 id="1-4-托勒密与地心说"><a href="#1-4-托勒密与地心说" class="headerlink" title="1.4 托勒密与地心说"></a>1.4 托勒密与地心说</h3><p>&emsp;&emsp;托勒密是希腊数学家，天文学家，地理学家和占星家，于公元二世纪发表了《天文学大成》一书，阐述宇宙的<code>地心说</code>体系。所谓地心说是指地球位于宇宙的中心，既不自转也不公转，是静止不动的。而其他天体围绕地球做匀速圆周运动，后来这个条件又弱化为行星的运行轨道可由几种圆周轨道的不同组合而确定。这个理论暗示了地球在众行星中鹤立鸡群，独孤求败。然而这确实也符合当时人们的经验：太阳和繁星东升西落，循环往复，仿佛都是在围绕着地球而服务。关于托勒密的生平史料记载的比较少，他的名字真正闪耀时却在一千多年后。那时欧洲中世纪时期的基督教由于将地球赋予特殊意义，因此要寻找理论的支持。这时地心说把地球单独拎出来的行为显然符合基督教的目的，从此地心说作为神创世之证据而显赫，其他行星的圆周运动也体现了神的<code>第一推动</code>。但托勒密当时的宇宙学说却与宗教并没有联系。</p><h3 id="1-5-哥白尼与日心说"><a href="#1-5-哥白尼与日心说" class="headerlink" title="1.5 哥白尼与日心说"></a>1.5 哥白尼与日心说</h3><p>&emsp;&emsp;哥白尼是<code>文艺复兴</code>时期波兰的天文学家，数学家，医生，神父。在十六世纪初，哥白尼提出了<code>日心说</code>，他认为太阳才是宇宙的中心，而非地球。春夏秋冬是地球围绕太阳公转的结果，日夜交替是地球自转的结果。这个新理论的形成与当时地心说的太复杂有关。按理说将地球看做宇宙中心不是很简单吗，但事实却不然，为了以地球为中心来预测其他星体的运行轨迹，往往需要做很复杂的计算。有些行星的运行轨迹单靠一个圆周并不能正确预测，所以当时的人们将那些轨迹分解为更多的圆周，圆周复圆周，圆周何其多。随着人们发现越来越多的星体后，这种计算方法很快因低效复杂而被人们摒弃。在寻找新的计算方法时，哥白尼发现若以太阳为中心，则可以非常简单地用同心圆的方式来解释太阳系行星的运动。计算的简洁性成为了日心说的有力证明。当然教会是不允许他讲授这个理论的，地心说都宣传了好些年了，现在说太阳才是宇宙中心，老脸往哪里搁？哥白尼也非常聪明地对待这个敏感的事，他在临终前才将这部描述日心说的巨作《天体运行论》发表出来。有趣的是，哥白尼并不是一位职业的天文学家，他大部分时间是大教堂里的一名教士，同时也是一名神医，他的科学研究是在业余时间完成的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&emsp;&emsp;以上简单介绍了古典物理学中力学史的内容，其实在古典时期电磁、光学、声学等物理学现象也都有被人们发现并了解规律，但力学史更具代表性并且与课本教材内容相性较好，因此这里更多是铺垫力学的发展史。如上所述的地心说与日心说虽是描述天体的运行，但为以后万有引力定律的发现做了强有力的支撑。与哥白尼同时期的丹麦天文学家第谷用肉眼观测星体运动长达二十年，其编制的恒星表至今仍具价值。德国科学家开普勒，作为第谷的接班人，发现了行星运动的三大定律，第一次提出太阳系行星运行的轨道是椭圆形而非圆形。这些天文学上的重要规律即将呼出一个统一的伟大理论。 另一方面，宇宙的中心从地球变为太阳，而且都在某些情况下适用，这暗示了宇宙中任何一个星体都可以当做中心，这也表明了宇宙其实并没有中心。从现在的观点来看，宇宙中心从地球转移到太阳不过是参考系的变换，其实谁做参考点都可以描述星体的运动，只不过是计算的复杂度不同罢了。宇宙像是一个膨胀的气球，里面的每个点都不特殊，而促进气球膨胀的推手现被命名为暗能量，尚未被研究清楚。</p>]]></content>
    
    
    
    <tags>
      
      <tag>心流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用Github和Hexo搭建个人博客</title>
    <link href="/2023/11/07/%E5%88%A9%E7%94%A8Github%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/11/07/%E5%88%A9%E7%94%A8Github%E5%92%8CHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>这篇文章简略概括一下利用Github和Hexo搭建个人博客的步骤。<a href="https://github.com/">Github</a>是一个面向开源及私有软件项目的托管平台，其中的Repositories(仓库)可用来储存个人博客的数据。<a href="https://hexo.io/">Hexo</a>是一个快速、简洁且高效的博客框架。Hexo使用<code>Markdown</code>(或其他渲染引擎)解析文章，可生成静态网页。关于如何利用这两样工具来搭建博客，网上已有很多的教程，现在只简介搭建的主要步骤。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="#%C2%B7%E5%89%8D%E5%A5%8F">1. 前奏</a></p><p><a href="#Github">1. 1  Github pages</a></p><p><a href="#%E5%AE%89%E8%A3%85Hexo">1. 2  安装Hexo</a></p><p><a href="#%C2%B7%E9%97%B4%E5%A5%8F">2. 间奏</a></p><p><a href="#%E5%88%A9%E7%94%A8Hexo%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2">2. 1  建立博客</a></p><p><a href="#%E9%A2%84%E5%AE%9E%E9%AA%8C">2. 2  预实验</a></p><p><a href="#%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98">2. 3  更换主题</a></p><p><a href="#%E4%B9%A6%E5%86%99%E6%96%87%E7%AB%A0">2. 4  书写文章</a></p><p><a href="#%C2%B7%E5%B0%BE%E5%A5%8F">3. 尾奏</a></p><p><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></p><p><a href="#%E9%99%84%E5%BD%95">附录</a></p><h2 id="·前奏"><a href="#·前奏" class="headerlink" title="·前奏"></a>·前奏</h2><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>首先注册<code>Github</code>账号，在自己的<code>Repositories</code>下新建一个仓库。需要注意新仓库名必须以<code>username.github.io</code>格式命名，且一个账号只能创建一个该类型仓库。其中<code>username</code> 是自己Github的用户名。</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>参考<a href="https://hexo.io/zh-cn/docs/">Hexo官方教程</a>，对于win用户(以下内容只适用于window系统，其他系统安装Hexo的过程请参考Hexo官方教程)，主要是先安装两个应用程序<a href="https://git-scm.com/download/win">Git</a>和<a href="https://nodejs.org/en/">Node.js</a>(10.0 及以上版本)。</p><p>推荐使用<a href="https://www.anaconda.com/">anaconda</a>安装环境：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">conda install -c anaconda git<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">conda install -c anaconda nodejs<br></code></pre></td></tr></table></figure><p>用<code>git --version</code>和<code>node --version</code>查看安装的版本。</p><p><strong>Git配置初始化</strong>：上述的两个应用程序安装完成后，在该conda环境中输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name &quot;username&quot;<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.email &quot;youremail@example.com&quot;<br></code></pre></td></tr></table></figure><p>其中，<code>username</code> 和 <code>youremail@example.com</code> 分别是自己的Github用户名及注册Github时用的邮箱。</p><p>配置完成后，用以下代码查看自己的配置信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --list<br></code></pre></td></tr></table></figure><p><strong>连接Git和Github</strong>：输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;<br></code></pre></td></tr></table></figure><p>回车运行后，最终会在<code>C:\Users\Administrator</code>生成一个<code>.ssh</code>文件，打开后会发现文件<code>id_rsa.pub</code>。</p><p>参考Github的<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account">文档</a>复制该文件里的内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">clip &lt; ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>接着进入<code>Github</code>主页，选择<code>setting</code>，创建新的 <code>SSH key</code> ，其中title随意，在key里面粘贴刚才复制的内容，点击 <code>Add SSH key</code> 完成。</p><p><strong>使用 npm 安装 Hexo</strong>：输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>没有出现error，即为安装成功。</p><h2 id="·间奏"><a href="#·间奏" class="headerlink" title="·间奏"></a>·间奏</h2><h3 id="利用Hexo建立博客"><a href="#利用Hexo建立博客" class="headerlink" title="利用Hexo建立博客"></a>利用Hexo建立博客</h3><p>在磁盘下新建一个空文件夹。接下来关于博客的所有内容都将在此文件夹下进行。在这个空文件夹目录下用anaconda输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">npm install<br>hexo init<br></code></pre></td></tr></table></figure><p>以上命令建立了网站所需的依赖包和初始文件。</p><p>然后配置本地文件到Github：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">npm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><p>接着用文本编辑器 (推荐Sublime Text3) 打开<code>_config.yml</code>文档，在文档底部填写<code>depoly</code>信息。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">deploy:<br>  type: git<br>  repository: https://github.com/username/username.github.io.git  <br>  #username处替换成自己的用户名<br>  branch: master<br></code></pre></td></tr></table></figure><h3 id="预实验"><a href="#预实验" class="headerlink" title="预实验"></a>预实验</h3><p>通过上述一系列操作，其实已经建立了最简单的博客。现在可以预览一下效果了。在博客文件所在的文件夹下输入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hexo g<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hexo s<br></code></pre></td></tr></table></figure><p>先不关闭git页面，打开浏览器，输入网址<code>http://localhost:4000</code>即可本地查看自己的博客啦！注意这里只是本地查看，别人是看不到的。这个操作过程同样适用于以后发博客前的预览草稿。</p><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>Hexo默认的主题是<code>Landscape</code>，这也是刚才预览时所看到样子。Hexo官网提供了不同风格的<a href="https://hexo.io/themes/">博客主题</a>，本网站所采用的是<a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a>。</p><p><strong>更换主题的方式</strong>：首先在<a href="https://hexo.io/themes/">Hexo官网主题</a>中选出自己喜欢的风格，这应该是所有步骤中最花时间的了。然后进入该作者的Github账号下下载压缩文件到本地电脑里。接着将其解压到博客所在文件夹的<code>themes</code>文件夹中，注意解压后文件的名字。最后配置Hexo的<code>_config.yml</code>文档，用文本编辑器打开该文档，找到<code>theme</code>一行，将<code>landscape</code>替换为刚才解压文件的名字。接下来就可以预览一下效果。</p><p>不同的主题自带有其专属的配置文件，例如Fluid主题本身也自带有一个<code>_config.yml</code>文档，可根据作者的提示来调整博客的外观。</p><h3 id="书写文章"><a href="#书写文章" class="headerlink" title="书写文章"></a>书写文章</h3><p>回到博客的根目录下 (即拥有<code>public</code>文件的那个文件夹)，执行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hexo new &#x27;first-blog&#x27;<br></code></pre></td></tr></table></figure><p>然后会发现在<code>source/_posts</code>文件夹下生成了一个名为<code>first-blog.md</code>的文档。其中后缀<code>md</code>代表该文档可按照<code>Markdown</code>语言编辑。因此以后就按此格式书写文章，所以需要了解一些<code>Markdown</code>的基本语法。</p><p>写好文章后，回到博客的根目录下，可通过以下命令将其更新到网站上：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hexo g<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hexo d<br></code></pre></td></tr></table></figure><p>然后登陆网址<code>username.github.io</code>就可以查看自己发布的博客啦。</p><h2 id="·尾奏"><a href="#·尾奏" class="headerlink" title="·尾奏"></a>·尾奏</h2><p><code>Markdown</code>基本语法</p><p><a href="https://coding.net/help/doc/project/markdown.html">https://coding.net/help/doc/project/markdown.html</a></p><p><a href="https://www.runoob.com/markdown/md-tutorial.html">https://www.runoob.com/markdown/md-tutorial.html</a></p><p><a href="http://note.youdao.com/iyoudao/?p=2411">http://note.youdao.com/iyoudao/?p=2411</a></p><p><strong>评论功能</strong></p><p><strong>域名绑定</strong></p><p>(待更新…)</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><p><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p></li><li><p><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p></li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>公众号<code>量子位</code>发布了一个更为简单的搭建博客的教程，不需要写代码，只需Github！<a href="https://www.qbitai.com/2020/01/11140.html">https://www.qbitai.com/2020/01/11140.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>收藏</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
